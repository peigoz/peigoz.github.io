(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{580:function(t,e,v){"use strict";v.r(e);var i=v(4),_=Object(i.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"git-flow-简单说明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#git-flow-简单说明"}},[t._v("#")]),t._v(" git-flow 简单说明")]),t._v(" "),v("h2",{attrs:{id:"场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[t._v("#")]),t._v(" 场景")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://blog.peigo.top/peigo/2022-05-24-23-43-12.png",alt:"场景说明"}})]),t._v(" "),v("ol",[v("li",[v("p",[t._v("线上的开发分支为 origin/dev 此时项目进度为 a")])]),t._v(" "),v("li",[v("p",[t._v("张三和李四都基于此时切出去 dev-1 和 dev-2")])]),t._v(" "),v("li",[v("p",[t._v("张三开发了 b 功能,李四开发了 c 功能,李四在张三前先提交了 c 至仓库(origin/dev a、c）,此时张三应该走的一个 git 流程。")])])]),t._v(" "),v("h2",{attrs:{id:"多路合并和快速前进的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多路合并和快速前进的区别"}},[t._v("#")]),t._v(" 多路合并和快速前进的区别")]),t._v(" "),v("h2",{attrs:{id:"多余的合并记录-多路合并"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多余的合并记录-多路合并"}},[t._v("#")]),t._v(" 多余的合并记录,多路合并")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("张三开发完 b 功能后,此时他的本地 dev 分支还处于只有 a 功能的时代,远程 dev 分支已经处于 a、c 时代,此时 A 执行了以下操作:")]),t._v(" "),v("ol",[v("li",[t._v("切换本地 dev 分支执行"),v("code",[t._v("git pull")]),t._v("将本地更新至 ac")]),t._v(" "),v("li",[t._v("切换本地 dev-1 分支执行"),v("code",[t._v("git merge dev")]),t._v(",此时分支情况：dev 分支有 ac,dev-1 有 ab,存在冲突情况,解完冲突后提交至远程 origin/dev-1 分支")]),t._v(" "),v("li",[t._v("创建合并请求合并至 origin/dev")])])]),t._v(" "),v("li",[v("p",[t._v("merge 后的 commit 记录： "),v("img",{attrs:{src:"https://blog.peigo.top/peigo/2022-05-24-23-42-37.png",alt:"多路合并commit记录"}})])]),t._v(" "),v("li",[v("p",[t._v("解完冲突后执行"),v("code",[t._v("git log")]),t._v(" 会发现此时 commit 记录多出了上面的这种信息,然而这种消息记录在实际上并没有太大作用,反而会干扰整个 commit 记录")])])]),t._v(" "),v("h2",{attrs:{id:"没有-merge-记录的合并-快速前进-fast-forword"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#没有-merge-记录的合并-快速前进-fast-forword"}},[t._v("#")]),t._v(" 没有 merge 记录的合并,快速前进 Fast-forword")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("假设张三开发完 b 功能时,李四还没有开发完 c,张三处于领先情况,此时张三同样执行了上面的操作：")]),t._v(" "),v("ol",[v("li",[t._v("切换本地 dev 分支执行"),v("code",[t._v("git pull")]),t._v("，发现本地还是 a,没有更新记录")]),t._v(" "),v("li",[t._v("切换本地 dev-1 分支执行 git merge dev,此时分支情况：dev 分支有 a,dev-1 有 ab,"),v("strong",[t._v("不存在冲突情况")]),t._v(",dev-1 处于"),v("strong",[t._v("在 a 的基础上再开发新功能领先于 dev")]),t._v("的时代。merge 完提交至远程 origin/dev-1 分支")]),t._v(" "),v("li",[t._v("创建合并请求合并至 origin/dev")])])]),t._v(" "),v("li",[v("p",[t._v("这是整个 merge 流程情况：")]),t._v(" "),v("ol",[v("li",[t._v("本地 dev(图例是 delete）执行 merge 前 dev 的 commit 记录："),v("br"),t._v(" "),v("img",{attrs:{src:"https://blog.peigo.top/peigo/2022-05-24-23-47-15.png",alt:"merge前本地dev的commit记录"}})]),t._v(" "),v("li",[t._v("执行 merge 前 dev-1 的 commit 记录："),v("br"),t._v(" "),v("img",{attrs:{src:"https://blog.peigo.top/peigo/2022-05-24-23-47-46.png",alt:"merge前dev-1的commit记录"}})]),t._v(" "),v("li",[t._v("执行 merge 时会发现提示 Fast-forword 信息,表示这是一个快路合并,不存在冲突："),v("br"),t._v(" "),v("img",{attrs:{src:"https://blog.peigo.top/peigo/2022-05-24-23-48-21.png",alt:"执行merge的提示"}})]),t._v(" "),v("li",[t._v("执行 merge 后 dev 和 dev-1 的 commit 记录："),v("br"),t._v(" "),v("img",{attrs:{src:"https://blog.peigo.top/peigo/2022-05-24-23-48-39.png",alt:"执行merge后的dev和dev-1的commit记录"}})])])]),t._v(" "),v("li",[v("p",[t._v("我们会发现多出了一条快路合并的 commit 信息(b 功能）,且没有第一种情况那个 merge 记录信息")])])]),t._v(" "),v("h2",{attrs:{id:"利用快路合并的特点在开头场景下屏蔽掉那些-merge-信息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#利用快路合并的特点在开头场景下屏蔽掉那些-merge-信息"}},[t._v("#")]),t._v(" 利用快路合并的特点在开头场景下屏蔽掉那些 merge 信息")]),t._v(" "),v("h2",{attrs:{id:"使用-git-rebase-替代直接-merge"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用-git-rebase-替代直接-merge"}},[t._v("#")]),t._v(" 使用 git rebase 替代直接 merge")]),t._v(" "),v("ol",[v("li",[t._v("在张三要提交 b 功能前,此时分支情况: 本地 dev 有 a,远程 origin/dev 有 a、c,本地 dev-1 有 a、b")]),t._v(" "),v("li",[t._v("那么我们应该执行一下流程：\n"),v("ol",[v("li",[t._v("切换至本地 dev 分支,执行"),v("code",[t._v("git pull")]),t._v("(也可以分开使用"),v("code",[t._v("git fetch")]),t._v("和"),v("code",[t._v("git merge")]),t._v("这个我自己也没用过,貌似比直接"),v("code",[t._v("git pull")]),t._v("会稳定,具体可自行了解),将本地 dev 更新至 a、b")]),t._v(" "),v("li",[t._v("切换回本地 dev-1,执行"),v("code",[t._v("git rebase dev")]),t._v("变基"),v("strong",[t._v("使 dev-1 上的 b 功能成为基于 a、c 的基础上而开发新功能")]),t._v(",在 rebase 的过程中也许会出现冲突(conflict),在这种情况,Git 会停止 rebase 并会让你去解决 冲突,解完冲突后在解决完冲突后，用"),v("code",[t._v("git add")]),t._v("命令去更新这些内容的索引(index), 然后，无需执行 "),v("code",[t._v("git commit")]),t._v(",只要执行"),v("code",[t._v("git rebase --continue")]),t._v("这样 git 会继续应用(apply)余下的补丁(假如你的 dev-1 有多个 commit 记录且都和此时的 dev 有冲突)")]),t._v(" "),v("li",[t._v("更新至远程 origin/dev-1 分支(此时远程可能和变基后的本地 dev-1 有冲突,以本地变基整理后的结果为准,直接使用"),v("code",[t._v("git push -f")]),t._v("覆盖远程记录),并创建合并请求合并至 origin/dev")])])])]),t._v(" "),v("h2",{attrs:{id:"commit-的原子性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#commit-的原子性"}},[t._v("#")]),t._v(" commit 的原子性")]),t._v(" "),v("ol",[v("li",[t._v("一个需求做到一半需要拉线上的代码同步的话，可以使用"),v("code",[t._v("git stash")]),t._v("放入本地缓存区，通过"),v("code",[t._v("git stash pop")]),t._v("或者"),v("code",[t._v("git stash apply XXX")]),t._v("恢复。不要用 commit。如果要用 commit，后面关于这个需求的 commit 就要整理成一个 commit 推上去再提 mr。整个流程最好保持一个需求一个 commit。")]),t._v(" "),v("li",[t._v("可使用"),v("code",[t._v("git commit --amend")]),t._v("沿用上一个 commit")]),t._v(" "),v("li",[t._v("如果已经出现了一个 feat 多个 commit 的话（前面没有用 commit --amend），还可以用 git rebase -i 去压缩（合并）若干个 commit 为一个 commit。")])]),t._v(" "),v("h2",{attrs:{id:"git-stash"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#git-stash"}},[t._v("#")]),t._v(" git stash")]),t._v(" "),v("ol",[v("li",[v("code",[t._v("git stash list")]),t._v(" 查看缓存列表")]),t._v(" "),v("li",[v("code",[t._v("git stash drop XXX")]),t._v(" 移除特定 stash")]),t._v(" "),v("li",[v("code",[t._v('git stash save "XXX"')]),t._v(" 添加 stash 说明")])])])}),[],!1,null,null,null);e.default=_.exports}}]);